name: Build, Attest & Sign Docker Image

on:
  workflow_call:
    outputs:
      image-ref:
        description: "Full image reference that was pushed"
        value: ${{ jobs.build-and-push.outputs.image-ref }}
      image-digest:
        description: "Content digest of the pushed image"
        value: ${{ jobs.build-and-push.outputs.image-digest }}
      oci-artifact-name:
        description: "Name of the exported runtime OCI artifact"
        value: ${{ jobs.build-and-push.outputs.oci-artifact-name }}
      platforms:
        description: "Resolved platform list used for the build"
        value: ${{ jobs.build-and-push.outputs.platforms }}
    inputs:
      image_name:
        description: "Docker image name (e.g. user/repo)"
        required: true
        type: string
      image_tags:
        description: "Comma-separated list of tags"
        required: true
        type: string
      dockerfile:
        description: "Path to the Dockerfile"
        required: true
        type: string
      context:
        description: "Build context"
        required: true
        type: string
      build-args:
        description: "Docker build args (one per line, optional)"
        required: true
        type: string
      platforms:
        description: "Comma- or newline-separated list of target platforms"
        required: false
        default: linux/amd64
        type: string
      oci-artifact-name:
        description: "Artifact name for the exported binaries bundle"
        required: false
        default: zallet-runtime-oci
        type: string
    secrets:
      dockerhub_registry:
        required: true
        description: "Docker Hub registry (e.g. docker.io)"
      dockerhub_username:
        required: true
        description: "Docker Hub username"
      dockerhub_password:
        required: true
        description: "Docker Hub password"
  workflow_dispatch:
    inputs:
      image_name:
        description: "Docker image name (e.g. user/repo)"
        required: true
        type: string
      image_tags:
        description: "Comma-separated list of tags"
        required: true
        type: string
      dockerfile:
        description: "Path to the Dockerfile"
        required: true
        type: string
      context:
        description: "Build context"
        required: true
        type: string
      build-args:
        description: "Docker build args (one per line, optional)"
        required: true
        type: string
      platforms:
        description: "Comma- or newline-separated list of target platforms"
        required: false
        default: linux/amd64
        type: string
      oci-artifact-name:
        description: "Artifact name for the exported binaries bundle"
        required: true
        type: string

permissions:
  id-token: write        # Needed for keyless signing with Cosign and checkout
  contents: read
  attestations: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    env:
      REGISTRY_HOST: docker.io
      IMAGE_NAMESPACE: ${{ secrets.dockerhub_registry }}
      IMAGE_NAME: ${{ inputs.image_name }}
      BUILD_ARGS_RAW: ${{ inputs['build-args'] }}
      OCI_ARTIFACT_NAME: ${{ inputs.oci-artifact-name }}
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-ref: ${{ steps.emit.outputs.image_ref }}
      oci-artifact-name: ${{ steps.emit.outputs.artifact_name }}
      platforms: ${{ steps.platforms.outputs.platforms }}
    steps:
      - name: Determine image repository
        run: |
          set -euo pipefail
          HOST="${REGISTRY_HOST:-docker.io}"
          NAMESPACE="${IMAGE_NAMESPACE:-}"
          IMAGE="${IMAGE_NAME}"
          if [[ -z "$IMAGE" ]]; then
            echo "image_name input is required" >&2
            exit 1
          fi
          if [[ -z "$NAMESPACE" ]]; then
            echo "DOCKERHUB_REGISTRY (namespace) secret is required" >&2
            exit 1
          fi
          NAMESPACE="${NAMESPACE#/}"
          NAMESPACE="${NAMESPACE%/}"
          IMAGE_REPO="${NAMESPACE}/${IMAGE}"
          echo "IMAGE_REPOSITORY=$IMAGE_REPO" >> "$GITHUB_ENV"
          echo "IMAGE_FULL_NAME=${HOST}/${IMAGE_REPO}" >> "$GITHUB_ENV"

      - name: Compute Docker image tags
        id: set-tags
        run: |
          set -euo pipefail
          TAGS="${{ inputs.image_tags }}"
          IFS=',' read -ra ELEMENTS <<< "$TAGS"
          TAGS_FIXED=""
          for ELEMENT in "${ELEMENTS[@]}"; do
            ELEMENT_TRIMMED="$(echo "$ELEMENT" | xargs)"
            [[ -z "$ELEMENT_TRIMMED" ]] && continue
            TAGS_FIXED+="${IMAGE_FULL_NAME}:$ELEMENT_TRIMMED,"
          done
          TAGS_FIXED=${TAGS_FIXED%,}
          if [[ -z "$TAGS_FIXED" ]]; then
            echo "No valid tags were computed" >&2
            exit 1
          fi
          echo "tags_fixed=$TAGS_FIXED" >> "$GITHUB_ENV"

      - name: Determine target platforms
        id: platforms
        env:
          RAW_PLATFORMS: ${{ inputs.platforms }}
        run: |
          set -euo pipefail
          RAW="${RAW_PLATFORMS:-linux/amd64}"
          RAW="${RAW//$'\r'/}"
          RAW="${RAW//$'\n'/,}"
          RAW="${RAW// /}"
          PRIMARY=""
          NORMALIZED=""
          IFS=',' read -ra CANDIDATES <<< "$RAW"
          for TOKEN in "${CANDIDATES[@]}"; do
            TOKEN="${TOKEN//[$'\t\r\n ']}"
            [[ -z "$TOKEN" ]] && continue
            NORMALIZED+="${TOKEN},"
            if [[ -z "$PRIMARY" ]]; then
              PRIMARY="$TOKEN"
            fi
          done
          NORMALIZED="${NORMALIZED%,}"
          if [[ -z "$NORMALIZED" ]]; then
            echo "No valid platforms were provided" >&2
            exit 1
          fi
          echo "platforms=$NORMALIZED" >> "$GITHUB_OUTPUT"
          echo "primary=$PRIMARY" >> "$GITHUB_OUTPUT"

      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false

      - name: Prepare export directory
        run: mkdir -p build/runtime

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      - name: Enable containerd image store
        uses: depot/use-containerd-snapshotter-action@2e6f905d28e7ca519b216e2219d00545537e9f46 # v1.0.0

      - name: Log in to Docker registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ${{ env.REGISTRY_HOST }}
          username: ${{ secrets.dockerhub_username }}
          password: ${{ secrets.dockerhub_password }}

      - name: Build & Push (SBOM + provenance)
        id: build
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          file: ${{ inputs.dockerfile }}
          context: ${{ inputs.context }}
          push: true
          platforms: ${{ steps.platforms.outputs.platforms }}
          tags: ${{ env.tags_fixed }}
          build-args: ${{ inputs['build-args'] }}
          sbom: true
          provenance: mode=max
          outputs: |
            type=registry,rewrite-timestamp=true,force-compression=true
            type=local,dest=./out,from=export,rewrite-timestamp=true,force-compression=true


      - name: Export binaries per platform
        env:
          PLATFORMS: ${{ steps.platforms.outputs.platforms }}
        run: |
          set -euo pipefail

          # Ensure platform list is available
          if [[ -z "${PLATFORMS:-}" ]]; then
            echo "No target platforms available for export" >&2
            exit 1
          fi

          # Ensure the ./out directory produced by the previous build step exists
          if [[ ! -d out ]]; then
            echo "Missing ./out directory created by the build step" >&2
            exit 1
          fi

          mkdir -p build/runtime
          printf '%s\n' "$PLATFORMS" | tr ',' '\n' > build/runtime/PLATFORMS

          IFS=',' read -ra PLATFORM_LIST <<< "$PLATFORMS"
          for PLATFORM in "${PLATFORM_LIST[@]}"; do
            PLATFORM_TRIMMED="$(echo "$PLATFORM" | xargs)"
            [[ -z "$PLATFORM_TRIMMED" ]] && continue

            # Internal representation: linux/amd64 -> linux-amd64
            PLATFORM_KEY="${PLATFORM_TRIMMED//\//-}"

            # Output folder from buildx: linux/amd64 -> linux_amd64
            PLATFORM_OUT="${PLATFORM_TRIMMED//\//_}"

            SRC="out/${PLATFORM_OUT}"
            DEST="build/runtime/${PLATFORM_KEY}"

            echo "Processing platform ${PLATFORM_TRIMMED}"
            echo " - Source: ${SRC}"
            echo " - Dest:   ${DEST}"

            # Ensure the source directory exists for this platform
            if [[ ! -d "${SRC}" ]]; then
              echo "Output folder for ${PLATFORM_TRIMMED} not found at ${SRC}" >&2
              exit 1
            fi

            rm -rf "${DEST}"
            mkdir -p "${DEST}"

            # Copy all files produced in the 'export' stage for this platform
            cp -a "${SRC}/." "${DEST}/"

            # Validate expected binary exists
            if [[ ! -s "${DEST}/zallet" ]]; then
              echo "Missing zallet binary for ${PLATFORM_TRIMMED} in ${DEST}" >&2
              exit 1
            fi

            echo "Export completed for ${PLATFORM_TRIMMED}"
          done

      - name: Install Cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0

      - name: Cosign sign image by digest (keyless OIDC)
        env:
          IMAGE_REF: ${{ env.IMAGE_FULL_NAME }}
          DIGEST: ${{ steps.build.outputs.digest }}
        run: |
          set -euo pipefail
          echo "Signing $IMAGE_REF@$DIGEST"
          cosign sign --yes "$IMAGE_REF@$DIGEST"

      - name: Generate SLSA provenance attestation (GitHub)
        uses: actions/attest-build-provenance@977bb373ede98d70efdf65b84cb5f73e068dcc2a # v3.0.0
        with:
          subject-name: ${{ env.IMAGE_FULL_NAME }}
          subject-digest: ${{ steps.build.outputs.digest }}
          push-to-registry: true

      - name: Upload exported binaries artifact
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: ${{ env.OCI_ARTIFACT_NAME }}
          path: build/runtime
          if-no-files-found: error

      - name: Emit workflow outputs
        id: emit
        run: |
          echo "image_ref=${IMAGE_FULL_NAME}" >> "$GITHUB_OUTPUT"
          echo "artifact_name=${OCI_ARTIFACT_NAME}" >> "$GITHUB_OUTPUT"
          echo "platforms=${RESOLVED_PLATFORMS}" >> "$GITHUB_OUTPUT"
        env:
          IMAGE_FULL_NAME: ${{ env.IMAGE_FULL_NAME }}
          OCI_ARTIFACT_NAME: ${{ env.OCI_ARTIFACT_NAME }}
          RESOLVED_PLATFORMS: ${{ steps.platforms.outputs.platforms }}
